#+title: tEBL Day 1: 简单的 C 回顾与链表的实现
#+author: 凉凉
* 前置需求
你需要了解简单的 C 语言以及如何使用 =gcc=, =llvm= 或 =msvc=
等编译器编译并运行你的 C 语言程序.

* Detour: 简单的 C 语言复习 (以及简单的 EBNF 介绍)
让我们来回顾一下一个简单的 C 语言程序 =hello_world.c=:

#+name: hello-world-c
#+begin_src C :tangle ./hello_world.c :exports both
  #include <stdio.h>

  int main (int argc, char **argv)
  {
    printf("Hello World\n");
    return 0;
  }
#+end_src

编译 [fn:how-to-compile-c] 并运行 [fn:how-to-run-program],
我们可以在标准输出 =stdout= [fn:what-is-stdio] 中得到如下的输出:

#+RESULTS: hello-world-c
: Hello World

如果我们将其抽象地来表述:

#+begin_example
  预处理
  预处理
  ...
  函数定义
  函数定义
  ...
#+end_example

当然, 这样的记号实在是过于含糊不清了,
我们需要给它一个 "清晰" [fn:what-i-mean-clear-here] 的定义.
+ 定义 =预处理= 为:

  #+begin_example
    预处理 ::= "#include" "<" 头文件名称或者相对路径 ">"
             | "#define"  宏名称   表达式
  #+end_example

  这里我们用 ~::=~ 符号表示规则的定义. 用 =|= 符号表示或, 即一个
  =预处理= 对应的表达式可以是 =#include < 头文件名称或者相对路径 >=,
  也可以是 =#define  宏名称   表达式=.
+ 定义 =函数定义= 为:

  #+begin_example
    函数定义 ::= 类型 函数名 函数参数 "{"
                   (表达式 ";")*
                 "}"
  #+end_example

  这里用 =*= 表示零次或多次的重复. 用 =(= 和 =)= 表示将括号内的元素看作一个整体,
  即我们可以在函数定义的 ={}= block 内看到 =表达式;=, =表达式;表达式;= 这样的东西.

用类似的规则, 我们可以定义一个简单的 C 语言 [fn:simple-c-ebnf]
的描述来作为我们 C 语言的复习:

#+begin_example
  类型     ::= "int"
             | "float"
             | "double"

  函数参数 ::= "(" ")"
             | "(" 类型 变量名 ")"
             | "("
                   类型 变量名
                   ("," 类型 变量名)+
               ")"

  表达式   ::=
             | 变量名                # x, x_y, 等等
             | 字面值                # 1, 2, 2.3, 'x', 等等
             | "(" 表达式 ")"        # ( x + 2 )
             | 变量名 "=" 表达式     # x = 2; 赋值
             | 表达式 "+" 表达式     # x + b; 加法
             | ...
#+end_example

一个有意思的例子 (=gen_c_by_enbf.c=) 是,
我们可以利用上面的规则来生成一个 "语法正确" 的 C 语言程序:

#+name: gen-c-by-ebnf
#+begin_src C :eval no
  #define RAND(x) (rand() % (x))

  void gen_type () {
    switch (RAND(3)) {
    case 0:  printf("int");   break;
    case 1:  printf("float"); break;
    case 2:  printf("char");  break;
    default: break;
    }
  }

  // ... see more in gen_c_by_enbf.c
#+end_src

注: 虽然语法正确, 但是可能并不是那么的语义正确.
一个简单的例子 [fn:random-seed-gen]:

#+begin_src shell :results verbatim :eval no-export
  gcc -o gen_c_by_ebnf gen_c_by_ebnf.c && ./gen_c_by_ebnf 11451
#+end_src

#+RESULTS:
#+begin_example
#define g 'p'
#include <YN2_7P_B.h>
#include <e9FgFv.h>
#include <Z5_bwx5S_.h>
#define _Z_ 8
#include <__B_Gh.h>
#define KeDWH43t5E 47611
float _Sa_MX(char _eX0H81, int vI, char uW_PyIFT_N, float n3c_fZ_c11, int h_J, float w3k__TJ_F, char U91, char _l143__D, int uUS8)
{
( ( W62j__8 = _2J_8J = 'A' ) );
( t_v );
}
#+end_example

小节: 在本节中稍微回顾了一下简单的 C 语言,
同时写了一个根据 EBNF 规则描述的通过递归实现的 C 语言文本生成器.
这其实没啥鸟用, 唯一的用处就是让大家了解 EBNF
可以用来描述一些比较有规律的语言; 同时让大家复习一下简单的 C
语言程序的阅读 (阅读 =gen_c_by_ebnf.c=).

* Footnotes
[fn:random-seed-gen] 这里我们通过设定一个 =11451=
作为随机数种子的方式来保证输出的一致性.
你也可以替换为自己的随机数种子或者不提供随机数种子,
即使用当前时间 =time(NULL)= 作为随机数种子来进行设置.

[fn:simple-c-ebnf] 这里的 "简单" C 语言指的是 C 语言的一个小小子集.
为了简单, 我们并不会实现全部的 C 语言. 如果你对完整的 C 语言的 EBNF 表述感兴趣,
你可以考虑参考 [[https://cs.wmich.edu/~gupta/teaching/cs4850/sumII06/The%20syntax%20of%20C%20in%20Backus-Naur%20form.htm][The syntax of C in Backus-Naur Form]] (Section A13 of
The C programming language, 2nd edition, by Brian W. Kernighan and
Dennis M. Ritchie,Prentice Hall, 1988.)

[fn:what-i-mean-clear-here] 这里的 "清晰" 定义其实借鉴了部分的 [[https://en.wikipedia.org/wiki/Extended_Backus–Naur_form][EBNF]] 语法,
只不过用中文作为非终结符 (noterminal) 的标记来更加容易接受吧...

[fn:what-is-stdio] 这里的 =stdout= (标准输出, *st*​an​*d*​ard *out*​put)
和以后会接触到的 =stdin= (标准输入, *st*​an​*d*​ard *in*​put) 和
=stderr= (标准错误输出, *st*​an​*d*​ard *err*​or) 是一种 [[https://en.wikipedia.org/wiki/Stream_(computing)][stream]] (流).
大家可以将其想象成一种管道, 可以从一个管道 (=input-stream=) 中读取数据,
可以从一个管道 (=output-stream=) 中写入数据 (=stderr= 可以看作是一种
=output-stream=).

[fn:how-to-run-program] =./hello_world= 这告诉你的 shell 运行
给定的路径上的可执行程序. 和通常直接输入 =ls=, =gcc=, =cd= 这样的命令不同,
对于后者, shell 会在 =PATH= (环境变量) 的路径下查找是否存在对应的可执行程序.

[fn:how-to-compile-c] 假如你并不会编译, 这里以 =gcc= 为例:
=gcc -o hello_world hello_world.c= (更多内容请参考手册)
